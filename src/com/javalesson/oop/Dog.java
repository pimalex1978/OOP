package com.javalesson.oop;

public class Dog {

    /*преимущества статического ПОЛЯ и переменной:
     * т.к. это атрибут Класса, а не объекта,
     * мы можем использовать , например, нумерацию сквозь все объекты, к-рые создаем,
     * эта переменная будет сохраняться сквозь все вызовы Конструктора*/
    /*указываем статическое ПОЛЕ dogsCount, мы его не обязаны инициализировать в этом месте
     * потому что оно у нас примитивное int и оно будет инициализированно со значением 0 автоматически */
    private static int dogsCount; //количество собак

    /*Класс, как чертеж, используется для создания многих объектов
     * ПОЛЯ - это переменные описывающие Состояние,к-рые мы описываем в Классе, не в методе
     * Поведение будет описываться ниже, но уже через определенные МЕТОДЫ, в частности bark(), bite()
     * Базовые модификаторы доступа public - доступно для всех внешних классов
     * 4 поля ниже определяют основные свойства (состояние) нашей собаки
     * */
    //private int PAWS = 4; //ноги у собаки. ЭТИ ЗНАЧЕНИЕ КОНСТАНТНЫЕ. не меняются от запуска к запуску
    public static final int PAWS = 4; //ЭТИ ЗНАЧЕНИЕ КОНСТАНТНЫЕ. не меняются от запуска к запуску
    //private int TAIL = 1; //хвост у собаки. ЭТИ ЗНАЧЕНИЕ КОНСТАНТНЫЕ. не меняются от запуска к запуску
    public static final int TAIL = 1; //хвост у собаки. ЭТИ ЗНАЧЕНИЕ КОНСТАНТНЫЕ. не меняются от запуска к запуску
    //преименование из paws => PAWS делаем через рефакторинг, чтоб везде изменились связи, аналогично tail=>TAIL
    //КОНСТАНТЫ мы не можем устанавливать с помощью геттеров и сеттеров
    //уберем или закомментирум соответствующий код геттеров и сеттеров ниже
    //КОНСТАНТЫ можно делать public т.к. это все равно безопасно
    //модификатор final, говорит что КОНСТАНТА НЕ ИЗМЕНЯЕМА
    private String name; //имя собаки
    private String breed; //порода собаки
    private Size size = Size.UNDEFINED; //размер собаки/ Как только мы завели "enum Size" мы можем поменять тип "String" на "Size"

    //модификатор доступа private говорит о том, что данное ПОЛЕ не будет доступно для вызова из другого Класса
    //т.е. мы не можем вызвать с помощью оператора '.' это ПОЛЕ из , например, Класса Main
    //это касается и МЕТОДОВ. ни будут доступны только из текущего Класса Dog
    //попробуем получить доступ к нашим полям из Main. это получится сделать если будет модификатор public
    //модификатор доступа public говорит, что ПОЛЕ или МЕТОД будут доступны из любого Класса в нашей программе
    //есть еще два других метода:
    //если не пишем модификатор доступа то он автоматически определяется, как package private, доступ только из нашего пакета com.javalesson.oop
    //и модификатор доступа protected. Доступ к нему возможен только через ПодКласс. (будет рассмотрен детальнее далее)
    //через расширяющий extends Класс BigDog, который расширяет и наследует Класс Dog
    //private ПОЛЯ он не может наследовать и воздействовать на них, но воздействует на ПОЛЯ с доступом public и protected
    //@Override protected void setPaws (int PAWS) {super.setPaws(PAWS);}
    //private - самый закрытый доступ;
    //package-private(default)-доступ в пределах данного пакета,
    // protected-доступ из подкласса
    //public - доступ отовсюду, из любого Класса
    /*доступ к ****private**** полям можно сделать ТОЛЬКО с помощью МЕТОДОВ, к-рые называются геттеры и сеттеры: get(), set()
     * эти методы будут публичные, потому что они должны быть доступние из других классов
     * Сетеры и Гетеры можно создать автоматически Code - Generate- Getter and Setter
     * Через SET и GET методы мы можем устанавливать значения ПОЛЕЙ*/

    /*создаем КОНСТРУКТОР
     * КОНСТРУКТОР - это аналог МЕТОДА, не совсем методо, но похож
     * и называется также как и наш Класс Dog
     * у Конструктора нет return type*/

    public Dog() {
        /*в конструкторе увеличиваем количество собак с каждым созданием объекта типа Dog
         * по сути записывая "new Dog()", мы обращаеся к Конструктору Dog
         * но пока Конструктор не создан, он был у нас в нашем Классе Dog не явно и пустой Конструктор объявлять не обязательно
         */
        dogsCount++;
        System.out.println("Dog's cout is " + dogsCount);//выводим сообщение о количестве собак

    }

    /*создаем статический метод get()
     * можно создать сеттер, но особого смысла вэтом нет*/
    public static int getDogsCount() {
        return dogsCount;
    }

    /*методы сеттеры и геттеры можем писать вручную, а лучше сгенерировать через Code - Generate...*/

    public void setName(String dogsName) { //т.обр. вызываем метод setName, возвращает он void, в () указываем ему имя, и в name сохраняем результат
        name = dogsName;
        /*   или так:
        public void setName(String name) {
        name = name;
        this.name = name; - this. указывается как ссылка к полю name. Т.е. ПОЛЮ текущего объекта из Класса Dog хотим присвоить переданное нами имя name
                            т.е "this.name" - это ПОЛЕ нашего Класса, а "name;" - это наш параметр.
        }
        */
        this.name = name; //this.-указывает на ссылку к ПОЛЮ name, передает ему имя name. Т.е. ПОЛЮ текущего объекта из Класса Dog хотим присвоить переданное нами имя name
    }

    /*создаем геттер , возвращаем имя, поэтому return type=String*/
    public String getName() { //здесь метод без параметров,т.к. метод знает,что его задача - вернуть имя
        return name;
    }

    /* исправим наши методы, чтобы они не позволяли присваивать не правильное значение
     * внедрим проверку с помощью if
     * т.е валидация значения находится в методе.
     * добавляем валидацию значения перед тем, как присвоить его
     * ПОЛЯМ ставим private (по возможности), за исключением редких случаев
     * */
    /*создаем метод set() уже для другого ПОЛЯ PAWS*/
   /* public void setPaws(int paws) {
        if (paws == 4) {
            this.PAWS = paws;
        } else {
            this.PAWS = 4; //здесь мы присваиваем PAWS нужное значение. это правда не всегда нужно. можно просто выдать сообщение
            System.out.println("User tried to assigh " + paws + " PAWS for a dog");
            System.out.println("Correct number is 4");
        }
    }*/

    /*public int getPaws() {
        return PAWS;
    }
*/
    /*public void setTail(int tail) {
        if (tail == 1) {
            this.TAIL = tail;
        } else {
            this.TAIL = 1; //здесь мы присваиваем TAIL нужное значение. это правда не всегда нужно. можно просто выдать сообщение
            System.out.println("User tried to assigh " + tail + " tails for a dog");
            System.out.println("Correct number is 1");
        }
    }*/
    /*public int getTail() {
        return TAIL;
    }*/

    public void setBreed(String breed) {
        this.breed = breed;
    }

    public String getBreed() {
        return breed;
    }

    //в зависимости от размера собака по разному лает и кусает
    /*сеттеры и геттеры сгенерировали*/
    public Size getSize() {
        return size;
    } //здесь тоже заменили тип "String" на "Size"

    //будем здесь использовать "enum Size", т.е. вместо (String size) ставим (Size size)
    public void setSize(Size size) {
        /*public void setSize(String size) {*/
        /*обязательно ставим валидацию, т.к. будет только 3 размера
         * понадобиться equals для сравнения двух строк,
         * а точнее equalsIgnoreCase, чтобы игнорировать регистр
         * имеем три размера Big, Average, Small и если хоть один совпадает, то присваиваем размер*/
        /*if (size.equalsIgnoreCase("Big") ||
                size.equalsIgnoreCase("Average") ||
                size.equalsIgnoreCase("Small")) {
            this.size = size;//присваиваем size в this.size , если хоть один размер совпадет, иначе выводим сообщение
        } else {
            System.out.println("Size should be one of these: Big, Average or Small");
        }*/
        this.size = size;
    }


    /*Определим методы,к-рые будут определять ПОВЕДЕНИЕ Класса Dog, поведение нашей собаки*/
//лаять
    /*ПОВЕДЕНИЕ в частности лаять bark() будет изменяться от параметра, в частности size*/
    public void bark() {
        /*
         * как только завели enum Size, то можем использовать switch case для проверки
         * здесь будет меньше ошибок, например не будет NullPointerException, если вдруг не установили размер
         * и еод более аккуратный и читать его удобно
         * */
        switch (size) {
            case BIG:
            case VERY_BIG:
                System.out.println("Wof - Wof");
                break;
            case AVERAGE:
                System.out.println("Raf - Raf");
                break;
            case SMALL:
            case VERY_SMALL:
                System.out.println("Tiaf - Tiaf");
                break;
            default:
                System.out.println("Dog's size is undefined");

        }
        /*if ("Big".equalsIgnoreCase(size)) {
            System.out.println("Wof - Wof");
        } else if ("Average".equalsIgnoreCase(size)) {
            System.out.println("Raf - Raf");
        } else {
            System.out.println("Tiaf - Tiaf");
        }*/
    }

    //кусать
    /*например, если собака Small, то она не кусает а только лает,
     * но когда их 3, тогда могут и укусить*/
    public void bite() {
        if (dogsCount > 2) {
            System.out.println("Dogs are biting you");
        } else {
            bark(); //вызываем метод bark, собака лает, из метода bite()

        }

    }
}
